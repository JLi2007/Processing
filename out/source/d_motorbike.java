/* autogenerated by Processing revision 1293 on 2024-10-18 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class d_motorbike extends PApplet {

class Motorbike {
    // FIELDS
    PVector position;
    PVector vel;
    PVector direction;
    int radius;
    float speed;
    int colour;
    int otherCarCount;

    // 0=Parked | 1=Moving | 2=Moving to parking spot
    int status;

    float timeToPark;
    int targetParkingSpot;
    float distanceToParkingSpot;
    boolean returningParker;
    
    // CONSTRUCTOR
    Motorbike(int colour, float x, float y, int r, float s, float pa) {
        this.position = new PVector(x,y);
        this.vel = new PVector(random(2.5f,5), random(2.5f,5));
        this.radius = r;
        this.speed = s;
        this.colour = colour;
        this.otherCarCount=0;
        this.timeToPark = pa;
        this.status = 1;
        this.returningParker=false;
    }
    
    // DRAWS BIKE
    public void drawMotorbike() {
        fill(this.colour);
        stroke(this.colour);
        circle(this.position.x, this.position.y, this.radius);
    }
    
    // MOVES BIKE
    public void animateMotorbike() {
        // increase speed as some gets lost over time
        if(this.returningParker){
            this.vel = new PVector(random(5,6), random(5,6));
            this.speed+=10;
            this.otherCarCount=0;
            this.returningParker=false;
        }
        // IF the motorbike is moving
        if (this.status == 1) {
            // If the timeToPark var is less than 5, the motorbike wants to park
            if (this.timeToPark < 5) {
                // motor parks don't care if the spot is already taken, parks wherever they want
                this.targetParkingSpot = PApplet.parseInt(random(1, 21));

                // sets status to "moving to parking spot"
                this.status = 2;

                // add the chosen parking spot to the arraylist
                takenParkingSpots.add(this.targetParkingSpot);
            } 

            // otherwise, decrease the variable
            else {
                this.timeToPark -= random(0.01f, 0.03f);
            }
            
            // reverse direction if there is a collision with parking lot
            if (parkingLotCollision()) {
                this.vel = this.vel.mult(-1);
            }

            // adds vel vector to position vector
            this.position.add(this.vel);

            // if the motorbike goes out of screen bounds, pick new direction
            if ((this.position.x > width - this.radius) || (this.position.x < this.radius) || (this.position.y < this.radius) || (this.position.y > height - this.radius)) {
                // Adjust position to be just inside the boundary
                this.position.x = constrain(this.position.x, this.radius, width - this.radius);
                this.position.y = constrain(this.position.y, this.radius, height - this.radius);
                this.pickNewDirection();
            }
        }

        // IF the motorbike is moving to a parking spot
        if (this.status == 2) {
            // finds target position (the position of the lot number) and calculates distance
            PVector targetPosition = numPositions.get(this.targetParkingSpot - 1);
            this.distanceToParkingSpot = PVector.dist(this.position, targetPosition);

            // substracts, normalizes, then multiplies with PVector
            PVector displacement = PVector.sub(targetPosition, this.position);
            this.direction = displacement.normalize();
            this.vel = PVector.mult(this.direction, this.speed);

            // difference in distance for odd/even parking spots (for visual enhancement)
            if(this.targetParkingSpot % 2 == 0){
                if (this.distanceToParkingSpot < 10) {
                    // sets status to "parked"
                    this.status = 0;
                    this.vel.set(0, 0);
                    // count the other bikes in the spot / planning to park at the spot
                    countOtherCarsInSpot();
                }
            } else{
                if (this.distanceToParkingSpot < 5) {
                    // sets status to "parked"
                    this.status = 0;
                    this.vel.set(0, 0);
                    // count the other bikes in the spot / planning to park at the spot
                    countOtherCarsInSpot();
                }
            }

            // adds vel vector to position vector 
            this.position.add(this.vel);
        }

        // IF the motorbike is parked
        if (this.status == 0) {
            // as soon as another vehicle is either on the parkingspot or planning to park there, motorbikes start complaining
            if(this.otherCarCount>1){
                parkingArgument();
                // reset so the argument stops when the other vehicle leaves
                this.otherCarCount=0;
                countOtherCarsInSpot();
            }
            // Increase the ambition and leave when it reaches 20
            this.timeToPark += random(0.04f,0.07f);
            if (this.timeToPark > 12) {
                // sets status back to "moving"
                this.status = 1;
                this.pickNewDirection();
                
                // Move the motorbike outside the parking lot
                do {
                    if(targetParkingSpot % 2 == 0){
                        this.position.x += 5;
                    } else{
                        this.position.x -= 5;
                    }
                } while (parkingLotCollision());

                // removes the chosen parking spot from the arraylist
                takenParkingSpots.remove(Integer.valueOf(this.targetParkingSpot));
                // reset 
                this.returningParker=true;
            }
        }
    }
    
    // picks a new direction
    public void pickNewDirection() {
        // uses randangle to make a direction pvector and multiply the velocity
        float randAngle = random(0, TWO_PI);
        this.direction = new PVector(cos(randAngle), sin(randAngle)); 
        this.vel = PVector.mult(this.direction, this.speed);
    }
    
    // checks collisions with the parking lot
    public boolean parkingLotCollision() {
        // uses the lotPositions PVector ArrayList for both lots
        if (this.position.y < lotPositions.get(3).y && this.position.y > lotPositions.get(0).y && this.position.x > lotPositions.get(0).x && this.position.x < lotPositions.get(3).x) {
            return true;
        }
        if (this.position.y < lotPositions.get(7).y && this.position.y > lotPositions.get(4).y && this.position.x > lotPositions.get(4).x && this.position.x < lotPositions.get(7).x) {
            return true;
        }
        return false;
    }

    // count the other bikes in the spot / planning to park at the spot
    public void countOtherCarsInSpot(){
        // loops through takenParkingSpots arrayList
        for (Integer spot : takenParkingSpots) {
            if (spot.equals(this.targetParkingSpot)) {
                this.otherCarCount++;
            }
        }
    }

    // Motorbikes argue when their spot is being invaded
    public void parkingArgument(){
        fill(random(190,225), random(0,20), random(0,10));
        String[] exclamations = {"^*@&*@#()!!!", "!!??&*@****", "#$%^&*!!", "@#$%^&*!!", "!Vidul!", "NONONO"};
        float yOffset = random(-this.radius, this.radius);
        float xOffset = random(-this.radius, this.radius);
        if(this.targetParkingSpot % 2 == 0){
            text(exclamations[PApplet.parseInt(random(exclamations.length))], 
                 this.position.x + xOffset,
                 this.position.y + yOffset);
        } else {
            text(exclamations[PApplet.parseInt(random(exclamations.length))], 
                 this.position.x + xOffset,
                 this.position.y + yOffset);
        }
    }
}
class ParkingLot {
    // FIELDS
    float lineWidth;
    float lineHeight;
    
    // CONSTRUCTOR
    ParkingLot() {
        this.lineWidth = 3.5f;
        this.lineHeight = 5;
    }

    // Draw parking lot with road lines
    public void drawParkingLot() {
        background(11, 173, 9);
        stroke(100,100,100);
        fill(100,100,100);
        // gray concrete
        rect(0, 0, width, height,150,150,100,100);
        drawRoadLines();
    }
    
    public void drawRoadLines() {
        // fill, color (yellow), weight
        fill(252, 232, 3);
        stroke(252, 232, 3);
        strokeWeight(3);
        
        // calculate important points on the lines
        float leftX = (width / this.lineWidth - 150) / 2;
        float rightX = width - (width / this.lineWidth - 150) / 2;
        float centerX = (width / this.lineWidth + 150) + ((ParkingSpace.widthCalculation(this.lineWidth) - 150) - (width / this.lineWidth + 150)) / 2;
        float topY = (height / this.lineHeight) / 2;
        float bottomY = (ParkingSpace.heightCalculation(this.lineHeight) + (height / this.lineHeight) / 2);
        
        // add new PVectors to arrayList 
        // top horizontal line
        horizontalLines.add(new PVector[]{new PVector(leftX, topY), new PVector(rightX, topY)});
        // bottom horitonzal line
        horizontalLines.add(new PVector[]{new PVector(leftX, bottomY), new PVector(rightX, bottomY)});
        // left vertical line
        verticalLines.add(new PVector[]{new PVector(leftX, topY), new PVector(leftX,bottomY)});
        // center vertical line
        verticalLines.add(new PVector[]{new PVector(centerX, 0), new PVector(centerX,height)});
        // right vertical line
        verticalLines.add(new PVector[]{new PVector(rightX, topY), new PVector(rightX,bottomY)});
        
        // draw the lines
        for (PVector[] line : horizontalLines) {
            line(line[0].x, line[0].y, line[1].x, line[1].y);
        }
        for (PVector[] line : verticalLines) {
            line(line[0].x, line[0].y, line[1].x, line[1].y);
        }
    }
}



class ParkingSpace {
    // FIELDS
    int lots = 2;
    float lineWidth;
    float lineHeight;
    int numSpots;
    int spaceIndex;
    boolean[] isVacant;
    
    // CONSTRUCTOR
    ParkingSpace(int numSpots) {
        this.lineWidth = 3.5f;
        this.lineHeight = 5;
        this.numSpots = numSpots;

        this.isVacant = new boolean[numSpots*4];

        // initialize all spaces to vacant
        for(int i = 0; i < numSpots*4; i++){
            this.isVacant[i] = true;
        }
    }
    
    // draws the parking grids
    public void drawParkingGrid() {
        // black parking lot background
        fill(80,80,80);
        stroke(80,80,80);
        makeRectangle(width / this.lineWidth - 150, height / this.lineHeight,(width / this.lineWidth + 150) - (width / this.lineWidth - 150), heightCalculation(this.lineHeight) - height / this.lineHeight);
        makeRectangle(widthCalculation(this.lineWidth) - 150, height / this.lineHeight, (widthCalculation(this.lineWidth) + 150) - (widthCalculation(this.lineWidth) - 150), heightCalculation(this.lineHeight) - height / this.lineHeight);
        
        // grid color (yellow), line width of parking grid
        stroke(252, 232, 3);
        strokeWeight(2);
        
        // two vertical lines
        line(width / this.lineWidth, height / this.lineHeight, width / this.lineWidth, heightCalculation(this.lineHeight));
        line(widthCalculation(this.lineWidth), height / this.lineHeight, widthCalculation(this.lineWidth), heightCalculation(this.lineHeight));
        
        // two sets of (a numSpots #) horizontal lines featuring extensive calculations
        // left column
        for (int i = 0; i < this.numSpots + 1; i++) {
            line(width / this.lineWidth - 150, height / this.lineHeight + i * (heightCalculation(this.lineHeight) - (height / this.lineHeight)) / this.numSpots, width / this.lineWidth + 150, height / this.lineHeight + i * (heightCalculation(this.lineHeight) - (height / this.lineHeight)) / this.numSpots);
        }
        // right column
        for (int i = 0; i < this.numSpots + 1; i++) {
            line(widthCalculation(this.lineWidth) - 150, height / this.lineHeight + i * (heightCalculation(this.lineHeight) - (height / this.lineHeight)) / this.numSpots, widthCalculation(this.lineWidth) + 150, height / this.lineHeight + i * (heightCalculation(this.lineHeight) - (height / this.lineHeight)) / this.numSpots);
        }
        drawParkingSpaces();
    }
    
    // CALCULATIONS THAT ARE USED MULTIPLE TIMES THROUGHOUT THE PROJECT 
    // height [used whenever something is required for the bottom of the vertical lines]
    public float heightCalculation(float lineHeight) {
        return height * (lineHeight - 1) / lineHeight;
    }
    // width [used whenever something is required for the rightmost parking grid]
    public float widthCalculation(float lineWidth) {
        return width * (lineWidth - 1) / lineWidth;
    }
    
    private void makeRectangle(float x1, float y1, float xs, float ys) {
        rect(x1,y1,xs,ys);
        // topleft corner
        lotPositions.add(new PVector(x1,y1));
        // topright corner
        lotPositions.add(new PVector(x1 + xs,y1));
        // bottomleft corner
        lotPositions.add(new PVector(x1,y1 + ys));
        // bottomright corner
        lotPositions.add(new PVector(x1 + xs,y1 + ys));
    }
    
    private void drawParkingSpaces() {
        // index for numbering the parking spaces
        spaceIndex = 1;
        // alignment and size
        textAlign(CENTER, CENTER);
        textSize(20);
        
        // printing text
        // left column
        for (int i = 0; i < this.numSpots; i++) {
            printText(this.spaceIndex++, width / this.lineWidth - 130, calculateYPos(i));
            printText(this.spaceIndex++, width / this.lineWidth + 130, calculateYPos(i));
        }
        // right column
        for (int i = 0; i < this.numSpots; i++) {
            printText(this.spaceIndex++, widthCalculation(this.lineWidth) - 130, calculateYPos(i));
            printText(this.spaceIndex++, widthCalculation(this.lineWidth) + 130, calculateYPos(i));
        }
    }
    
    // extensive calculation to find the y pos of text (centered in between yellow lines)
    private float calculateYPos(int i) {
        return(height / this.lineHeight + i * (heightCalculation(this.lineHeight) - (height / this.lineHeight)) / this.numSpots) + 
           ((i + 1) * ((heightCalculation(this.lineHeight) - (height / this.lineHeight)) / this.numSpots) - (i * (heightCalculation(this.lineHeight) - (height / this.lineHeight)) / this.numSpots)) / 2;
    }
    
    // prints text
    private void printText(int index, float x, float y) {
        fill(isVacant[index-1] ? color(0, 219, 18) : color(219, 0, 4));
        text(index, x, y);
        
        // add to pvector
        numPositions.add(new PVector(x,y));
    }
}


class Bike {
    // FIELDS
    PVector position;
    PVector vel;
    PVector direction;
    int radius;
    float speed;
    int colour;

    // 0=Parked | 1=Moving | 2=Moving to parking spot
    int status;

    float timeToPark;
    int targetParkingSpot;
    float distanceToParkingSpot;
    boolean returningParker;

    // CONSTRUCTOR
    Bike(int colour, float x, float y, int r, float s, float pa) {
        this.position = new PVector(x,y);
        this.vel = new PVector(random(1.5f,3), random(1.5f,3));
        this.radius = r;
        this.speed = s;
        this.colour = colour;
        this.timeToPark = pa;
        this.status = 1;
        this.returningParker=false;
    }
    
    // DRAWS BIKE
    public void drawBike() {
        fill(this.colour);
        stroke(this.colour);
        circle(this.position.x, this.position.y, this.radius);
    }
    
    // MOVES BIKE
    public void animateBike() {
        // increase speed as some gets lost over time
        if(this.returningParker){
            this.vel = new PVector(random(3,5), random(3,5));
            this.speed+=10;
            this.returningParker=false;
        }
        
        // IF the bike is moving
        if (this.status == 1) {
            // If the timeToPark var is less than 5, the bike wants to park
            if (this.timeToPark < 5) {
                // finds a targetParkingSpot that isn't already occupied, contradictory to motor bikes
                if (takenParkingSpots.size() < 21) {
                    do {
                        this.targetParkingSpot = PApplet.parseInt(random(1, 21));
                    } while (takenParkingSpots.contains(this.targetParkingSpot));

                    // sets status to "moving to parking spot"
                    this.status = 2;

                    // add the chosen parking spot to the arraylist
                    takenParkingSpots.add(this.targetParkingSpot);
                }else{
                    this.timeToPark+=random(1,5);
                }
            } 

            // otherwise, decrease the variable
            else {
                this.timeToPark -= random(0.01f, 0.03f);
            }
            
            // reverse direction if there is a collision with parking lot
            if (parkingLotCollision()) {
                // Reverse direction
                this.vel = this.vel.mult(-1);
            }

            // adds vel vector to position vector
            this.position.add(this.vel);

            // if the bike goes out of screen bounds, pick new direction
            if ((this.position.x > width - this.radius) || (this.position.x < this.radius) || (this.position.y < this.radius) || (this.position.y > height - this.radius)) {
                // Adjust position to be just inside the boundary
                this.position.x = constrain(this.position.x, this.radius, width - this.radius);
                this.position.y = constrain(this.position.y, this.radius, height - this.radius);
                this.pickNewDirection();
            }
        }

        // IF the bike is moving to a parking spot
        if (this.status == 2) {
            // finds target position (the position of the lot number) and calculates distance
            PVector targetPosition = numPositions.get(this.targetParkingSpot - 1);
            this.distanceToParkingSpot = PVector.dist(this.position, targetPosition);

            // substracts, normalizes, then multiplies with PVector
            PVector displacement = PVector.sub(targetPosition, this.position);
            this.direction = displacement.normalize();
            this.vel = PVector.mult(this.direction, this.speed);

            // difference in distance for odd/even parking spots (for visual enhancement)
            if(this.targetParkingSpot % 2 == 0){
                if (this.distanceToParkingSpot < 10) {
                    // sets status to "parked"
                    this.status = 0;
                    this.vel.set(0, 0);
                }
            } else{
                if (this.distanceToParkingSpot < 5) {
                    // sets status to "parked"
                    this.status = 0;
                    this.vel.set(0, 0);
                }
            }

            // adds vel vector to position vector 
            this.position.add(this.vel);
        }

        // IF the bike is parked
        if (this.status == 0) {            
            // Increase the ambition and leave when it reaches 20
            this.timeToPark += random(0.04f,0.07f);
            if (this.timeToPark > 10) {
                // sets status back to "moving"
                this.status = 1;
                this.pickNewDirection();

                // Move the bike outside the parking lot
                do {
                    if(targetParkingSpot % 2 == 0){
                        this.position.x += 5;
                    } else{
                        this.position.x -= 5;
                    }
                } while (parkingLotCollision());

                    // removes the chosen parking spot from the arraylist
                takenParkingSpots.remove(Integer.valueOf(this.targetParkingSpot));
                // reset
                this.returningParker=true;
            }
        }
    }
    
    // picks a new direction
    public void pickNewDirection() {
        // uses randangle to make a direction pvector and multiply the velocity
        float randAngle = random(0, TWO_PI);
        this.direction = new PVector(cos(randAngle), sin(randAngle)); 
        this.vel = PVector.mult(this.direction, this.speed);
    }
    
    // checks collisions with the parking lot
    public boolean parkingLotCollision() {
        // uses the lotPositions PVector ArrayList for both lots
        if (this.position.y < lotPositions.get(3).y && this.position.y > lotPositions.get(0).y && this.position.x > lotPositions.get(0).x && this.position.x < lotPositions.get(3).x) {
            return true;
        }
        if (this.position.y < lotPositions.get(7).y && this.position.y > lotPositions.get(4).y && this.position.x > lotPositions.get(4).x && this.position.x < lotPositions.get(7).x) {
            return true;
        }
        return false;
    }
}
// James Li
// October 17, 2024
// Parking Lot Simulation

// VARIABLES
// *the program can crash if there are too many bikes on the road.
int numBikes = 20;
int numMotorbikes = 10;
float bikeX, bikeX2, bikeX3;
int xReturn = 0;
ParkingLot ParkingLot;
ParkingSpace ParkingSpace;

ArrayList<Bike> bikes;
ArrayList<Motorbike> motorBikes;

// positions of lot numbers
ArrayList<PVector> numPositions = new ArrayList<PVector>();
// positions of the lot boundaries
ArrayList<PVector> lotPositions = new ArrayList<PVector>();
// arrayList PVectors for roadlines
ArrayList<PVector[]> horizontalLines = new ArrayList<PVector[]>();
ArrayList<PVector[]> verticalLines = new ArrayList<PVector[]>();
ArrayList<Integer> takenParkingSpots = new ArrayList<Integer>();

public void setup() {
    /* size commented out by preprocessor */;
    println("Parking Lot Simulation");
    // initializa ParkingLot and ParkingSpace
    ParkingLot = new ParkingLot();
    ParkingSpace = new ParkingSpace(5);

    // initialize bikes and motorBikes
    bikes = new ArrayList<Bike>();
    motorBikes = new ArrayList<Motorbike>();
    
    // draw parking lot and parking spaces
    ParkingLot.drawParkingLot();
    ParkingSpace.drawParkingGrid();
    
    // populate bikes and motorbikes
    for (int bike = 0; bike < numBikes; bike++) {
        bikes.add(new Bike(color(random(0, 255), random(0, 255), random(0, 255)), randomX(), random(height), 50, 5, random(10)));
    }
    
    for (int motorbike = 0; motorbike < numMotorbikes; motorbike++) {
        motorBikes.add(new Motorbike(color(random(0,225)), randomX(), random(height), 50, 10, random(12)));
    }
}

public void draw() {
    background(11, 173, 9);
    ParkingLot.drawParkingLot(); 
    ParkingSpace.drawParkingGrid();  
    
    // draw bikes and motorbikes
    for (Bike bike : bikes) {
        bike.drawBike(); 
        bike.animateBike();
    }
    for (Motorbike motorbike : motorBikes) {
        motorbike.drawMotorbike(); 
        motorbike.animateMotorbike();
    }
}

// return random x coordinate that are not on top of the parking grids
public float randomX() {
    bikeX = random(width / 15, lotPositions.get(0).x - width / 15);
    bikeX2 = random(lotPositions.get(1).x + width / 15, lotPositions.get(4).x - width / 15);
    bikeX3 = random(lotPositions.get(5).x + width / 15, width);
    
    if (xReturn < 3) {xReturn += 1;} 
    else{
        xReturn = 1;
    }
    
    if (xReturn ==  1) {
        return bikeX;
    }
    else if (xReturn ==  2) {
        return bikeX2;
    }
    else{
        return bikeX3;
    }
}


  public void settings() { size(1500, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "d_motorbike" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
