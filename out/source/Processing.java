/* autogenerated by Processing revision 1293 on 2024-10-07 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import g4p_controls.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class processing extends PApplet {



float xMin, xMax, yMin, yMax;
float mx, my, bx, by;
float a, b;
int numRays = 600;
int maxNumRays = 1000;
float raySpeed;
float xBulb = 0, yBulb = 0;
String drawingMode = "particles"; //"particles"

Bulb bulb;
QuadraticCurve e;


public void setup(){
  /* size commented out by preprocessor */;
  createGUI();
  
  xMin = -width/2;  xMax = width/2;
  yMin = -height/2; yMax = height/2;
  
  mx = width/(xMax-xMin);
  bx = -mx*xMin;
  my = -height/(yMax-yMin);
  by = -my*yMax;
  
  a = width/2;  //default values
  b = a;
  
  numRays = 1000;
  raySpeed = 2.0f;

  stroke(255);

  e = new QuadraticCurve(a, b);  
  bulb = new Bulb(a/2, 0, raySpeed, numRays);
}


public void draw() {
  background(0);
  stroke(255);
  noFill();
  e.drawMe();
  
  bulb.drawObjects();
  bulb.updateObjects();
}
class Bulb {
  Ray[] rays;
  float xC, yC;
  float raySpeed;
  
  //A Bulb object keeps track of all the Ray objects that belong to it at all times
  Bulb(float x, float y, float rs, int numRays){
    this.xC=x;
    this.yC=y;
    this.raySpeed=rs;
    
    rays = new Ray[numRays];
    
    float dTheta = 2*PI/numRays;
    float theta=0;
    
    //Make all the rays point outwards in a circle from the starting point (xC, yC)
    for(int i=0; i<rays.length; i++){
      float xSpeed = raySpeed * cos(theta);
      float ySpeed = raySpeed * sin(theta);
      rays[i] = new Ray(xC, yC, xSpeed, ySpeed); 
      theta += dTheta;
    }
  }
    
    
  public void drawMe() {
    fill(255,255,0);
    float xScreenCentre = getScreenX( xC );
    float yScreenCentre = getScreenY( yC );
  
    ellipse(xScreenCentre, yScreenCentre, 10, 10);
  }
  
  
  public void updateObjects(){
    for(int i=0;i<this.rays.length;i++){
      rays[i].update();
    }
  }
  
  
  public void rotateRays(float angle){
    for(int i=0; i<this.rays.length; i++){
      rays[i].rotateBy(angle);
    }
  }
  
  
  public void drawObjects() {
    if (drawingMode.equals("particles")) {
      this.drawParticles();
    }
    
    else {
      this.drawRays();
    }
  }
  
  
  public void drawRays(){
    stroke(255);
    for(int i=0; i<this.rays.length; i++){
      rays[i].drawRay();
    }
  }
  
  
 public void drawParticles(){
    noStroke();
    for(int i=0; i<this.rays.length; i++){
      rays[i].drawParticle();
    }
  }
}

public void resetParameters() {
  a = PApplet.parseFloat(aSlider.getValueI())/100.0f * xMax; 
  b = PApplet.parseFloat(bSlider.getValueI())/100.0f * yMax; 
  raySpeed = PApplet.parseFloat(speedSlider.getValueI())/2.0f;
  numRays = min( PApplet.parseInt(numRaysTextfield.getText()), maxNumRays );
  String bulbPlacement = bulbPlacementList.getSelectedText();
  
  e = new QuadraticCurve(a, b); 

  if (bulbPlacement.equals("Center")) {
    xBulb = 0; 
    yBulb = 0;
  }
  
  else if (bulbPlacement.equals("Focus")) {
    xBulb = e.f1x; 
    yBulb = e.f1y;
  }
  
  else if (bulbPlacement.equals("Left edge")) {
    xBulb = -a*0.99f; 
    yBulb = 0;
  }
  
  else if (bulbPlacement.equals("Top edge")) {
    xBulb = 0; 
    yBulb = b*0.99f;
  }
  
  else if (bulbPlacement.equals("1/4 between foci")) {
    if (a >= b) {
      xBulb = e.f1x * 0.25f + e.f2x * 0.75f;
      yBulb = 0;
    }
    
    else {
      xBulb = 0; 
      yBulb = e.f1y * 0.25f + e.f2y * 0.75f;
    }
  }

  bulb = new Bulb( xBulb, yBulb, raySpeed, numRays );
}


public float getAngle(float vx, float vy, float wx, float wy){
  float dotProd = vx*wx + vy*wy;
  float vMag = sqrt(vx*vx + vy*vy);
  float wMag = sqrt(wx*wx + wy*wy);
  return acos(dotProd/(vMag*wMag));
}


public float getScreenX(float xMath) {
  return xMath + bx;
}


public float getScreenY(float yMath) {
  return by - yMath;
}
public void mouseClicked() {
  xBulb = mouseX - width/2;
  yBulb = height/2 - mouseY;
  
  if (e.eval(xBulb, yBulb) < 0) 
    bulb = new Bulb( xBulb, yBulb, raySpeed, numRays);
}
class QuadraticCurve {
  float a, b;                      //The equation of an ellipse is x^2/a^2 + y^2/b^2 = 1.  If a == b, then the ellipse is just a circle with radius b
  float c;                         //Focal length of the ellipse
  float aSq, bSq, invaSq, invbSq;  //Precomputed constants that come in handy in the formulas below
  float f1x, f1y, f2x, f2y;        //Coordinates of the foci
  
  
  QuadraticCurve(float a, float b){
    this.a = a;
    this.b = b;
    this.aSq = a*a;
    this.bSq = b*b;
    this.invaSq = 2/aSq;
    this.invbSq = 2/bSq;
    setFoci();
  }
  
  
  public void setFoci() {
    if(a >= b) {
        this.c = sqrt(aSq - bSq);
        this.f1x = -this.c;
        this.f1y = 0;
        this.f2x = this.c;
        this.f2y = 0;
    }
      
    else {
        this.c = sqrt(bSq - aSq);
        this.f1x = 0;
        this.f1y = -this.c;
        this.f2x = 0;
        this.f2y = this.c;
    }
  }
  
  
  //Used for determining if the location of a red ball at (x,y) is inside or outside the ellipse.
  //Returns negative --> (x,y) is inside the ellipse   
  //Returns positive --> (x, y) is outside the ellipse    
  //Returns zero -->     (x, y) is on the ellipse
  public float eval(float x, float y) {
    return x*x/aSq + y*y/bSq - 1; 
  }

  
  //Returns the slope of the normal vector to the ellipse at point (x, y)
  public PVector gradient(float x, float y) {
    float fx = x * invaSq;  //fx = x/a^2
    float fy = y * invbSq;  //fy = y/b^2
    return new PVector(fx, fy);
  }
  
  
  public void drawMe(){
    ellipse(getScreenX(0),getScreenY(0), 2*a, 2*b); //Drawing the main ellipse
    fill(255,0,0);
    ellipse(getScreenX(f1x), getScreenY(f1y), 10, 10);  //Drawing the two foci as red dots
    ellipse(getScreenX(f2x), getScreenY(f2y), 10, 10);
  }
}
class Ray {
  float baseX, baseY, tipX, tipY, speedX, speedY;
  float reverseSpeedX, reverseSpeedY;
  boolean outsideCurve;
  float insideness; //negative=inside the ellipse, positive=outside
  
  Ray(float bx, float by, float sx, float sy){
    this.baseX=bx;
    this.baseY=by;
    this.tipX=bx;
    this.tipY=by;
    this.speedX=sx;
    this.speedY=sy;
    resetReverseSpeed();
  }
  
  
  public void resetReverseSpeed() {
    this.reverseSpeedX = -this.speedX/10;
    this.reverseSpeedY = -this.speedY/10;
  }
    
  
  public void update() {
    float prevInsideness = e.eval(this.tipX, this.tipY); //Determines whether the ray's tip was inside or outside the ellipse in the previous frame
    
    this.tipX += this.speedX;  //Where the ray would be in this frame
    this.tipY += this.speedY;
    
    float currInsideness = e.eval(this.tipX, this.tipY); //Determines whether the ray's tip will be inside or outside the ellipse in the current frame
    
    if( prevInsideness < 0 && currInsideness >= 0) {    //If the ray was inside the ellipse last frame but would go outside in this frame, then we've detected a bounce
        correctToBoundary();                       //Resets the ray to be exactly on the ellipse's surface
        float rotationAngle = getRotationAngle();  //Determines the angle by which the ray will bounce according to the reflection law
        this.rotateBy( rotationAngle );            //Rotates the ray by that angle
    }
  }
  
  
  public void correctToBoundary() {
    while( e.eval(this.tipX, this.tipY) >= 0 ) {  //While the tip is still outside the ellipse...
      this.tipX += this.reverseSpeedX;  //...back the ray up along the direction it came from
      this.tipY += this.reverseSpeedY;
    }
  }
  
  
  //Determines the bouncing angle of a ray that has just hit the ellipse's wall
  public float getRotationAngle() {
    PVector grad = e.gradient(this.tipX, this.tipY);  //The gradient vector of the ellipse at the collision point
    float alpha = getAngle(this.speedX, this.speedY, grad.x, grad.y);  //The angle between the ray's incoming velocity vector and the normal vector to the ellipse 
                                                                       //at the point of contact
    
    if( -this.speedX*grad.y + this.speedY*grad.x >= 0 )
      return PI-2*alpha; //rotate the ray by PI - 2*alpha radians counter-clockwise
      
    else
      return 2*alpha-PI;  //rotate clockwise
  }
  
  
  public void rotateBy(float angle) {
    float s = sin(angle);
    float c = cos(angle);
    float speedXold = this.speedX;
    
    this.speedX = speedX*c - speedY*s;
    this.speedY = speedXold*s + speedY*c;
    resetReverseSpeed();
    
    this.baseX = this.tipX;  //The point of contact is now the new base of the ray. 
    this.baseY = this.tipY;
  }
  
  
  public void drawRay(){
    float xScreenBase = getScreenX(this.baseX);
    float yScreenBase = getScreenY(this.baseY);
    
    float xScreenTip = getScreenX(this.tipX);
    float yScreenTip = getScreenY(this.tipY);
    
    line(xScreenBase, yScreenBase, xScreenTip, yScreenTip);
  }
  
  
  public void drawParticle(){
    float xScreenTip = getScreenX(this.tipX);
    float yScreenTip = getScreenY(this.tipY);
    
    circle(xScreenTip, yScreenTip, 4);
  }
}
/* =========================================================
 * ====                   WARNING                        ===
 * =========================================================
 * The code in this tab has been generated from the GUI form
 * designer and care should be taken when editing this file.
 * Only add/edit code inside the event handlers i.e. only
 * use lines between the matching comment tags. e.g.

 void myBtnEvents(GButton button) { //_CODE_:button1:12356:
     // It is safe to enter your event code here  
 } //_CODE_:button1:12356:
 
 * Do not rename this tab!
 * =========================================================
 */

synchronized public void controlsWindow_draw1(PApplet appc, GWinData data) { //_CODE_:controlsWindow:918147:
  appc.background(230);
} //_CODE_:controlsWindow:918147:

public void bSliderChanged(GSlider source, GEvent event) { //_CODE_:bSlider:563356:
  resetParameters();
} //_CODE_:bSlider:563356:

public void speedSliderChanged(GSlider source, GEvent event) { //_CODE_:speedSlider:843400:
  resetParameters();
} //_CODE_:speedSlider:843400:

public void numRaysTextfieldChanged(GTextField source, GEvent event) { //_CODE_:numRaysTextfield:778730:
  resetParameters();
} //_CODE_:numRaysTextfield:778730:

public void bulbPlacementListChanged(GDropList source, GEvent event) { //_CODE_:bulbPlacementList:878161:
  resetParameters();
} //_CODE_:bulbPlacementList:878161:

public void aSliderChanged(GSlider source, GEvent event) { //_CODE_:aSlider:251711:
  resetParameters();
} //_CODE_:aSlider:251711:

public void rayParticlesButtonClicked(GButton source, GEvent event) { //_CODE_:rayParticlesButton:598733:
  if(drawingMode.equals("particles")) {
    drawingMode = "rays";
    rayParticlesButton.setText("Draw particles");
  }
    
  else {
    drawingMode = "particles";
    rayParticlesButton.setText("Draw rays");
  }
} //_CODE_:rayParticlesButton:598733:



// Create all the GUI controls. 
// autogenerated do not edit
public void createGUI(){
  G4P.messagesEnabled(false);
  G4P.setGlobalColorScheme(GCScheme.BLUE_SCHEME);
  G4P.setCursor(ARROW);
  surface.setTitle("Sketch Window");
  controlsWindow = GWindow.getWindow(this, "controls", 0, 0, 500, 400, JAVA2D);
  controlsWindow.noLoop();
  controlsWindow.addDrawHandler(this, "controlsWindow_draw1");
  label1 = new GLabel(controlsWindow, 10, 30, 100, 20);
  label1.setText("Ellipse height");
  label1.setTextBold();
  label1.setOpaque(false);
  bSlider = new GSlider(controlsWindow, 120, 20, 229, 40, 10.0f);
  bSlider.setShowValue(true);
  bSlider.setLimits(75, 10, 100);
  bSlider.setNbrTicks(10);
  bSlider.setNumberFormat(G4P.INTEGER, 0);
  bSlider.setOpaque(false);
  bSlider.addEventHandler(this, "bSliderChanged");
  label2 = new GLabel(controlsWindow, 10, 120, 80, 20);
  label2.setText("Ray speed");
  label2.setOpaque(false);
  speedSlider = new GSlider(controlsWindow, 90, 110, 172, 40, 10.0f);
  speedSlider.setShowValue(true);
  speedSlider.setLimits(2, 0, 10);
  speedSlider.setNbrTicks(10);
  speedSlider.setNumberFormat(G4P.INTEGER, 0);
  speedSlider.setOpaque(false);
  speedSlider.addEventHandler(this, "speedSliderChanged");
  label3 = new GLabel(controlsWindow, 10, 180, 158, 20);
  label3.setText("Number of rays (max 600)");
  label3.setOpaque(false);
  numRaysTextfield = new GTextField(controlsWindow, 170, 180, 50, 30, G4P.SCROLLBARS_NONE);
  numRaysTextfield.setText("1000");
  numRaysTextfield.setOpaque(true);
  numRaysTextfield.addEventHandler(this, "numRaysTextfieldChanged");
  label4 = new GLabel(controlsWindow, 10, 230, 129, 20);
  label4.setText("Light bulb placement");
  label4.setOpaque(false);
  bulbPlacementList = new GDropList(controlsWindow, 150, 230, 150, 220, 10);
  bulbPlacementList.setItems(loadStrings("list_878161"), 0);
  bulbPlacementList.addEventHandler(this, "bulbPlacementListChanged");
  label6 = new GLabel(controlsWindow, 10, 70, 100, 20);
  label6.setText("Ellipse width");
  label6.setOpaque(false);
  aSlider = new GSlider(controlsWindow, 120, 60, 230, 40, 10.0f);
  aSlider.setShowValue(true);
  aSlider.setLimits(75, 10, 100);
  aSlider.setNumberFormat(G4P.INTEGER, 0);
  aSlider.setOpaque(false);
  aSlider.addEventHandler(this, "aSliderChanged");
  rayParticlesButton = new GButton(controlsWindow, 10, 270, 80, 30);
  rayParticlesButton.setText("Draw particles");
  rayParticlesButton.addEventHandler(this, "rayParticlesButtonClicked");
  controlsWindow.loop();
}

// Variable declarations 
// autogenerated do not edit
GWindow controlsWindow;
GLabel label1; 
GSlider bSlider; 
GLabel label2; 
GSlider speedSlider; 
GLabel label3; 
GTextField numRaysTextfield; 
GLabel label4; 
GDropList bulbPlacementList; 
GLabel label6; 
GSlider aSlider; 
GButton rayParticlesButton; 


  public void settings() { size(600, 600); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "processing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
