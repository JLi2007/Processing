/* autogenerated by Processing revision 1293 on 2024-10-09 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class processing extends PApplet {

public void setup() {
  Fraction e = new Fraction( 1, 2 );  
  Fraction f = new Fraction( 5, 3, "f" );  
  Fraction g = new Fraction( 20, 80, "g" );


  //USING THE display() METHOD
  e.display();
  f.display();
  g.display();

  // power
  Fraction h = new Fraction(3, 2, "h");
  Fraction h5 = h.power(5);
  h5.display();

  Fraction j = new Fraction( 2.4f, "j" );
  Fraction k = new Fraction( 0.375f, "k" );

  j.display();
  k.display();



  println();
  exit();

  //USING THE reduce() METHOD
  //g.reduce();
  //g.display();

  //println();
         
 // USING THE toDecimal() METHOD
  //float fDecimal = f.toDecimal();
  //float gDecimal = g.toDecimal();
  //println( f.label + " is equivalent to " + fDecimal);
  //println( g.label + " is equivalent to " + gDecimal);






  //println();

  //USING METHODS THAT CREATE AND RETURN NEW FRACTION OBJECTS: reciprocal(), multiply(), add(), power()
  //Fraction oneOverF = f.reciprocal(); 
  //oneOverF.display();

  //Fraction oneOverG = g.reciprocal();
  //oneOverG.display();
  
  //println();

  //Fraction prodFG = f.multiply(g);
  //prodFG.display();
 
  
  
 // println();

  //YOUR TURN: CODE THE power() METHOD
  //Fraction fToTheFour = f.power(4);
  //fToTheFour.display();

  ////CODE THE add() METHOD
  //Fraction sumFG = f.add(g);
  //sumFG.display();


  //USING STATIC METHODS OF THE FRACTION CLASS: getGCD AND getLCM
  //STATIC MEANS THAT THE METHOD DOESN'T WORK WITH ANY PARTICULAR FRACTION OBJECT.
  //THAT IS, THE METHOD BELONGS TO THE CLASS AS A WHOLE, AND NOT TO ANY PARTICULAR OBJECT OF THAT CLASS.
  //STATIC METHODS ARE CALLED INSIDE setup() USING THE SYNTAX Fraction.staticMethodName() INSTEAD OF f.methodName() WHERE f IS SOME FRACTION OBJECT

  //int gcd = Fraction.getGCD(12, 15);
  //int lcm = Fraction.getLCM(12, 15); //CODE THE getLCM() METHOD
}
static class Fraction {
 
  //FIELDS
  int numerator;
  int denominator; 
  String label;
  String emoState;
       
  //CONSTRUCTOR 1
  Fraction( int n, int d ) {
    this.numerator = n;
    this.denominator = d;
    this.label = "";
  }
  
  //CONSTRUCTOR 2
  Fraction( int n, int d, String l ) {
    this.numerator = n;
    this.denominator = d;
    this.label = l;
  }

  //CONSTRUCTOR 3
  Fraction( float x, String l){
    String decimals = split(nf(x), ".")[1];
    float multiply = pow(10, decimals.length());
    float newX = x*multiply;
    for(int reduce=PApplet.parseInt(multiply); reduce>0; reduce--){
      if(newX%reduce ==0 && multiply%reduce==0){
        newX /= reduce;
        multiply /= reduce;
        this.numerator=PApplet.parseInt(newX);
        this.denominator=PApplet.parseInt(multiply);
        this.label=l;
        return;
      }
    }
    this.numerator=PApplet.parseInt(newX);
    this.denominator=PApplet.parseInt(multiply);
    this.label=l;
  }

  //METHODS
  public void display() {         
    String printedFrac = this.numerator + "/" + this.denominator; 
    
    if ( this.label.equals( "" ) )
      println( printedFrac );
    
    else
      println( this.label + " = " + printedFrac );   
  }
  
  public void reduce() {
    int gcd = getGCD( this.numerator, this.denominator );
    
    this.numerator /= gcd;
    this.denominator /= gcd;       
  }
 
  public float toDecimal() {
    return PApplet.parseFloat(this.numerator) / this.denominator; 
  }
 
  //METHODS THAT RETURN A NEW FRACTION OBJECT
  public Fraction reciprocal() {
    return new Fraction( this.denominator, this.numerator, "1 / " + this.label);
  }
  
  
  public Fraction multiply( Fraction other ) {
    int num2 = this.numerator * other.numerator;
    int den2 = this.denominator * other.denominator;
    
    Fraction p = new Fraction( num2, den2, this.label + "x" + other.label   );
    return p;
  }

  public Fraction power(int exponent){
     int num3 = PApplet.parseInt(pow(this.numerator,exponent));
     int den3 = PApplet.parseInt(pow(this.denominator,exponent));

     Fraction p = new Fraction(num3, den3, this.label + "^" + exponent);
     return p;
  }
  
  
  //The following 4 methods are "static". 
  //Static methods are just "helper methods" that don't require information about any particular Fraction object.
  //To call a static method inside setup, you use <CLASS NAME>.<METHOD NAME> instead of <OBJECT VARIABLE NAME>.<METHOD NAME>  
  //For example, Fraction.getGCD(6, 8);
  public static int getGCD(int a, int b) { //Euclid's algorithm
    int max, min, rem;
    
    max = max(a, b);
    min = min(a, b);
    
    rem = max % min;
    
    while (rem > 0) {
      max = min;
      min = rem;
      rem = max % min;
    }
    
    return min;
  }
  
  
  public static int getLCM(int a, int b) {
    //CODE THIS ON YOUR OWN
    return -1;
  }
  
  
  //This method is "private" because it's only needed by other methods in the class, and not by setup().
  //The user has no access to it from setup().
  private static boolean isWholeNumber( float d ) {
    return d == round(d);
  }
  
} //END OF FRACTION CLASS


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "processing" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
