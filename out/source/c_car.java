/* autogenerated by Processing revision 1293 on 2024-10-16 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class c_car extends PApplet {

class Car{
    PVector position;
    float speed;
    int colour;
    float parkingSize;
    // 0=east | 1=west | 2=north | 3=south
    float direction;
    // 0=Parked | 1=Leaving Parking | 2=Driving
    int status;
    boolean rightOfWay;

    // required to obtain lotPositions
    ArrayList<PVector> lotPositions;
    
    Car(int colour, float x, float y){
        this.position = new PVector(x,y);
        this.speed = random(1,2);
        this.colour = colour;
        this.parkingSize = 1;
        this.direction = 0;
        this.status = 2;
        this.rightOfWay = false;
        this.lotPositions = parkingSpaces.getLotPositions();
    }

    public void drawCar(){
        fill(this.colour);
        stroke(this.colour);
        // println(this.position.x);
        // println(lotPositions.get(0)[0].x);
        // determining direction of the car
        // if above parking lots
        // if(this.position.x.sub(lotPositions[0].x)<0){
        //     println("he");
        // //     if(this.position.x < parkingLot.horizontalLines[0].x){
        // //         this.direction=1;
        // //     }else{
        // //         this.direction=0;
        // //     }
        // // }
        // // if(this.position.x > lotPositions[3].x){
        // //     if(this.position.x > parkingLot.horizontalLines[1].x){
        // //         this.direction=0;
        // //     }else{
        // //         this.direction=1;
        // //     }
        // }

        // PLACEHOLDER
        if(this.direction==0){
            rect(this.position.x, this.position.y, width/15, height/20);
        }else{
            rect(this.position.x, this.position.y, height/20, width/15);
        }
    }
}
class parkingLot{
    float lineWidth;
    float lineHeight;
    parkingSpaces parkingSpaces;
    // arrayList PVectors for roadlines
    ArrayList<PVector[]> horizontalLines = new ArrayList<PVector[]>();
    ArrayList<PVector[]> verticalLines = new ArrayList<PVector[]>();

    parkingLot(){
        this.lineWidth = 3.5f;
        this.lineHeight = 5;
        this.parkingSpaces = new parkingSpaces(6);
    }
    
    public void drawParkingLot(){
        background(11, 173, 9);
        stroke(100,100,100);
        fill(100,100,100);
        rect(0, 0, width, height,150,150,100,100);
        parkingSpaces.drawParkingGrid();
        drawRoadLines();
    }

    public void drawRoadLines(){
        // fill, color (yellow), weight
        fill(252, 232, 3);
        stroke(252, 232, 3);
        strokeWeight(3);
        
        // calculate important points on the lines
        float leftX = (width/this.lineWidth-150)/2;
        float rightX = width-(width/this.lineWidth-150)/2;
        float centerX = (width/this.lineWidth +150)+((parkingSpaces.widthCalculation(this.lineWidth)-150) - (width/this.lineWidth+150))/2;
        float topY = (height/this.lineHeight)/2;
        float bottomY = (parkingSpaces.heightCalculation(this.lineHeight) + (height/this.lineHeight)/2);

        // add new PVectors to arrayList 
        // top horizontal line
        horizontalLines.add(new PVector[]{new PVector(leftX, topY), new PVector(rightX, topY)});
        // bottom horitonzal line
        horizontalLines.add(new PVector[]{new PVector(leftX, bottomY), new PVector(rightX, bottomY)});
        // left vertical line
        verticalLines.add(new PVector[]{new PVector(leftX, topY), new PVector(leftX,bottomY)});
        // center vertical line
        verticalLines.add(new PVector[]{new PVector(centerX, 0), new PVector(centerX,height)});
        // right vertical line
        verticalLines.add(new PVector[]{new PVector(rightX, topY), new PVector(rightX,bottomY)});

        // draw the lines
        for (PVector[] line : horizontalLines){
            line(line[0].x, line[0].y, line[1].x, line[1].y);
        }
        for (PVector[] line : verticalLines){
            line(line[0].x, line[0].y, line[1].x, line[1].y);
        }
    }

    public ArrayList<PVector[]> getHLinePositions(){
        return horizontalLines;
    }

    public ArrayList<PVector[]> getVLinePositions(){
        return verticalLines;
    }
}



public class parkingSpaces{
    int lots = 2;
    float lineWidth;
    float lineHeight;
    int numSpots;
    int spaceIndex;
    // MAY REMOVE THIS one
    ArrayList<PVector> numPositions = new ArrayList<PVector>();
    static ArrayList<PVector> lotPositions = new ArrayList<PVector>();
    boolean[] isVacant;

    parkingSpaces(int numSpots){
        this.lineWidth = 3.5f;
        this.lineHeight = 5;
        this.numSpots = numSpots;
        this.isVacant = new boolean[numSpots*4];

        // initialize all spaces to vacant
        for(int i = 0; i < numSpots*4; i++){
            this.isVacant[i] = true;
        }
    }

    public void drawParkingGrid(){
        // black parking lot background
        fill(80,80,80);
        stroke(80,80,80);
        makeRectangle(width/this.lineWidth-150, height/this.lineHeight, (width/this.lineWidth+150)-(width/this.lineWidth-150), heightCalculation(this.lineHeight)-height/this.lineHeight);
        makeRectangle(widthCalculation(this.lineWidth)-150, height/this.lineHeight,  (widthCalculation(this.lineWidth)+150)-(widthCalculation(this.lineWidth)-150), heightCalculation(this.lineHeight)-height/this.lineHeight);

        // grid color (yellow), line width of parking grid
        stroke(252, 232, 3);
        strokeWeight(2);

        // two vertical lines
        line(width/this.lineWidth, height/this.lineHeight, width/this.lineWidth, heightCalculation(this.lineHeight));
        line(widthCalculation(this.lineWidth), height/this.lineHeight, widthCalculation(this.lineWidth), heightCalculation(this.lineHeight));

        // two sets of (a numSpots #) horizontal lines featuring extensive calculations
        // left column
        for(int i = 0; i < this.numSpots+1; i++){
            line(width/this.lineWidth-150, height/this.lineHeight + i*(heightCalculation(this.lineHeight)-(height/this.lineHeight))/this.numSpots, width/this.lineWidth+150, height/this.lineHeight + i*(heightCalculation(this.lineHeight)-(height/this.lineHeight))/this.numSpots);
        }
        // right column
        for(int i = 0; i < this.numSpots+1; i++){
            line(widthCalculation(this.lineWidth)-150, height/this.lineHeight + i*(heightCalculation(this.lineHeight)-(height/this.lineHeight))/this.numSpots, widthCalculation(this.lineWidth)+150, height/this.lineHeight + i*(heightCalculation(this.lineHeight)-(height/this.lineHeight))/this.numSpots);
        }
        drawParkingSpaces();
    }

    // CALCULATIONS THAT ARE USED MULTIPLE TIMES THROUGHOUT THE PROJECT 
    // height [used whenever something is required for the bottom of the vertical lines]
    public float heightCalculation(float lineHeight){
        return height*(lineHeight-1)/lineHeight;
    }
    // width [used whenever something is required for the rightmost parking grid]
    public float widthCalculation(float lineWidth){
        return width*(lineWidth-1)/lineWidth;
    }

    private void makeRectangle(float x1, float y1, float xs, float ys){
        rect(x1,y1,xs,ys);
        // topleft corner
        lotPositions.add(new PVector(x1,y1));
        // topright corner
        lotPositions.add(new PVector(x1+xs,y1));
        // bottomleft corner
        lotPositions.add(new PVector(x1,y1+ys));
        // bottomright corner
        lotPositions.add(new PVector(x1+xs,y1+ys));
    }

    // to obtain lotPositions from other files
    public static ArrayList<PVector> getLotPositions() {
        return lotPositions;
    }

    private void drawParkingSpaces(){
        // index for numbering the parking spaces
        spaceIndex = 1;
        // alignment and size
        textAlign(CENTER, CENTER);
        textSize(20);

        // printing text
        // left column
        for(int i = 0; i < this.numSpots; i++){
            printText(this.spaceIndex++, width/this.lineWidth-130, calculateYPos(i));
            printText(this.spaceIndex++, width/this.lineWidth+130, calculateYPos(i));
        }
        // right column
        for(int i = 0; i < this.numSpots; i++){
            printText(this.spaceIndex++, widthCalculation(this.lineWidth)-130, calculateYPos(i));
            printText(this.spaceIndex++, widthCalculation(this.lineWidth)+130, calculateYPos(i));
        }
    }

    // extensive calculation to find the y pos of text (centered in between yellow lines)
    private float calculateYPos(int i){
        return (height/this.lineHeight + i*(heightCalculation(this.lineHeight) - (height/this.lineHeight))/this.numSpots) + 
        ((i+1)*((heightCalculation(this.lineHeight) - (height/this.lineHeight))/this.numSpots) - (i*(heightCalculation(this.lineHeight) -(height/this.lineHeight))/this.numSpots))/2;
    }

    // prints text - color is dependant on if the space is vacant
    private void printText(int index, float x, float y){
        fill(isVacant[index-1] ? color(0, 219, 18) : color(219, 0, 4));
        text(index, x, y);

        // add to pvector
        numPositions.add(new PVector(x,y));
    }
}


// James Li
// October 18, 2024
int numCars = 3;
parkingLot parkingLot;
ArrayList<Car> cars;

public void setup(){
    /* size commented out by preprocessor */;
    println("Parking Lot Simulation");
    parkingLot = new parkingLot();
    cars = new ArrayList<Car>();

    for(int car=0; car<numCars; car++){
        cars.add(new Car(color(random(0, 255), random(0, 255), random(0, 255)), random(1,width), random(1,height)));
    }
}

public void draw(){
    parkingLot.drawParkingLot();
    for (Car car : cars){
        car.drawCar();
    }
}


  public void settings() { size(1500, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "c_car" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
