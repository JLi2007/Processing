/* autogenerated by Processing revision 1293 on 2025-01-01 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import g4p_controls.*;
import processing.javafx.*;
import java.util.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class a_Block extends PApplet {

class Block{
  float x, y;
  Edge edge;
  
  Block(Edge e){
    this.edge =  e;
  }
  
  public void showBlock(){
    imageMode(CENTER);
    x = (edge.n1.x + edge.n2.x)/2;
    y = (edge.n1.y + edge.n2.y)/2;
    image(cone,x,y);
  }
}
ArrayList<Node> path; //stores the path

Node startNode = null, endNode = null;

HashMap<Node, ArrayList<Pair>> adj; //adjacency list where each node stores an arraylist of pairs (and each pair stores a connected node and the weight)

public void setValues(){ //create adjacency list
  adj =  new HashMap<Node, ArrayList<Pair>>();
  for(Edge e: edges){
    if(e.exists){ //sometimes the edge will be "blocked", prevents creating unwanted paths
      adj.put(e.n1, new ArrayList<Pair>());
      adj.put(e.n2, new ArrayList<Pair>());
    }
    
  }
  for(Edge e: edges){
    if(e.exists){
      adj.get(e.n1).add(new Pair (e.dist, e.n2)); 
      adj.get(e.n2).add(new Pair (e.dist, e.n1));
    }
  }
  for(Node n: nodes){
    n.SD = 100000.0f;
    n.vis = false;
    n.prev = null;
  }
  
}

public void findPath(){
  //priority queue automatically sorts the queue and picks the smallest value (since we put distance as the first value in the pair, it will sort by shortest distance)
  PriorityQueue<Pair> queue = new PriorityQueue<Pair>(); 
  path = new ArrayList<Node>();
  queue.add(new Pair(0, startNode)); // distance, node (so the priority queue can sort based on distance)
  startNode.SD = 0;
  startNode.prev = null;
  
  while(queue.isEmpty()==false && startNode!=null){
    Pair curPair = queue.poll(); //gets the min.value and removes it from queue
    Node curNode = curPair.second;
    
    if(curNode.vis) continue;
    curNode.vis=true;
    
    if(adj.containsKey(curNode)){ // if the current node has connected nodes
      for(Pair nxt : adj.get(curNode)){ //loop through each connected node
        Node nxtNode = nxt.second;
        float weight = nxt.first;

        if(nxtNode.SD > curNode.SD+weight){ 
          nxtNode.SD = curNode.SD+weight;
          nxtNode.prev = curNode;
          queue.add(new Pair(nxtNode.SD, nxtNode));
        }
        
      }
    }
    
  }
  showPath();
}

public void showPath(){
  for(Edge e: edges){
    e.inPath = false;
  }
  
  if(endNode.vis){
    for(Node n = endNode; n != null; n = n.prev){
      path.add(n);
    }
  }
   
  Collections.reverse(path);
  
  for(Node n: nodes){
    if(!path.contains(n)) {
      if(n.col!=clicked) n.col = og;
    }
  }
  
  for(Node n: path){
    n.col = chosenPath;
    if(n.prev!=null){
      for(Edge e: edges){
        if((e.n1 == n.prev && e.n2 == n) || (e.n2 == n.prev && e.n1 == n)){
          e.col = chosenPath;
          e.inPath = true;
        }
      }
    }
  }
  
  
  for(Edge e: edges){
    if(!e.inPath && e.col!=blocked) e.col = og;
  }
  
}
class Edge{
  Node n1, n2; //two nodes that make up this edge
  float dist;
  float w = 15; //width of  node
  float deltaX, deltaY; // slope of node (split up to avoid division by zero)
  float [][] corners = new float[5][2]; //coordinates of each corner of the edge
  boolean exists = true; // whether it has been blocked or not
  int col = og; //colour
  boolean inPath = false; //part of the shortest path or not
  
  Edge(Node node1, Node node2){
    this.n1 = node1;
    this.n2 = node2;
    this.dist = dist(n1.x, n1.y, n2.x, n2.y);
  }
  
  public void updateDist(){
    this.dist = dist(n1.x, n1.y, n2.x, n2.y);
  }
  
  public void drawEdge(){
    deltaX = (n2.x-n1.x)/dist;
    deltaY = (n2.y-n1.y)/dist;
    corners[0] = new float[] { n1.x + (-deltaY * w/2), n1.y + (deltaX * w/2) };
    corners[1] = new float[] { n1.x + (-deltaY * -w/2), n1.y + (deltaX * -w/2) };
    corners[2] = new float[] { n2.x + (-deltaY * -w/2), n2.y + (deltaX * -w/2) };
    corners[3] = new float[] { n2.x + (-deltaY * w/2), n2.y + (deltaX * w/2) };
    
    beginShape();
    fill(col);
    for(int i = 0; i < 4; i++){
      vertex(corners[i][0], corners[i][1]);
    }
    endShape();
    
    if(showDistance) displayDist();

  }
  
  public boolean isClicked(){ //Checks to see if edge is clicked
    int i, j; boolean c = false;
    for (i = 0, j = 3; i < 4; j = i++) {
      //Draw a horizontal (finite) ray from (mouseX, mouseY)
      //Count how many edges it crosses
      //If the number of crossings is odd, point is inside the shape
 
      if ( ((corners[i][1]>mouseY) != (corners[j][1]>mouseY)) && (mouseX < (corners[j][0]-corners[i][0]) * (mouseY-corners[i][1]) / (corners[j][1]-corners[i][1]) + corners[i][0]) )
        c = !c;
    }
    return c;
  }
  
  public void displayDist(){
    fill(0);
    textAlign(CENTER);
    if(exists) text(str(PApplet.parseInt(dist)), (n1.x + n2.x) / 2, (n1.y + n2.y) / 2);
  }
  
}
class Node{
  float x, y;
  float s = 20; //size of node
  int col = og;
  String label = "";
  float SD = 100000.0f;
  Node prev;
  boolean vis = false;
  
  Node(float x, float y, String str){
    this.x = x;
    this.y = y;
    this.label = str;
  }
  
  
  public boolean isClicked(){
    if(x-s <= mouseX && mouseX <= x+s){
      if(y-s <= mouseY && mouseY <= y+s){
        col = clicked;
        return true;
      }
    }
    return false;
  }
  
  public void showNode(){
    fill(col);
    circle(x,y,2*s);
    fill(0);
    textFont(f);
    textAlign(CENTER);
    text(label,x,y);
    
  }
 
  
}
class Pair implements Comparable<Pair>{
  float first; Node second;
  
  Pair(float first, Node second){
    this.first = first;
    this.second = second;
    
  }
  
  public int compareTo(Pair tmp){
    if(first < ((Pair) tmp).first) return -1;
    else if (first > ((Pair) tmp).first) return 1;
    
    return 0;
  }
  
  
}
/* =========================================================
 * ====                   WARNING                        ===
 * =========================================================
 * The code in this tab has been generated from the GUI form
 * designer and care should be taken when editing this file.
 * Only add/edit code inside the event handlers i.e. only
 * use lines between the matching comment tags. e.g.

 void myBtnEvents(GButton button) { //_CODE_:button1:12356:
     // It is safe to enter your event code here  
 } //_CODE_:button1:12356:
 
 * Do not rename this tab!
 * =========================================================
 */

synchronized public void win_draw1(PApplet appc, GWinData data) { //_CODE_:window1:550632:
  appc.background(230);
} //_CODE_:window1:550632:

public void options_click1(GDropList source, GEvent event) { //_CODE_:options:216535:
  String choice = options.getSelectedText();
  //if(!runStart){
   if(choice.equals("Node")) mode = "node";
   else if(choice.equals("Edge")){
     mode = "edge";
   }
  else if(choice.equals("Road block")) mode = "block";
  else mode = "";
  
} //_CODE_:options:216535:

public void startCheckbox_clicked(GCheckbox source, GEvent event) { //_CODE_:startCheckbox:510514:
  if(!startChecked) startChecked = true;
  else startChecked = false;
} //_CODE_:startCheckbox:510514:

public void endCheckBox_clicked(GCheckbox source, GEvent event) { //_CODE_:endCheckBox:880380:
  if(!endChecked) endChecked = true;
  else endChecked = false;
} //_CODE_:endCheckBox:880380:

public void clearEdges_click(GButton source, GEvent event) { //_CODE_:clearEdgesButton:734808:
  edges = new ArrayList<Edge>();
  for(Node n: nodes) n.col = og;
  runStart = false;
  run.setText("Run");
} //_CODE_:clearEdgesButton:734808:

public void runButton_click(GButton source, GEvent event) { //_CODE_:run:301769:
  String runButtonText = run.getText();
  if(runButtonText.equals("Run")){
    if(startNode!=null && endNode != null){
      runStart = true;
      setValues();
      findPath();
      run.setText("Pause");
      options.setSelected(0);
      mode = "";
    }
  }
  else{
    run.setText("Run");
    for(Node n: nodes){
      n.col = og;
    }
    
    for(Edge e: edges){
      if(e.col!=blocked) e.col = og;
    }
    runStart = false;
  }
} //_CODE_:run:301769:

public void showDist_clicked(GCheckbox source, GEvent event) { //_CODE_:showDist:534802:
  if(!showDistance) showDistance = true;
  else showDistance = false;
} //_CODE_:showDist:534802:

public void clearNodes_click(GButton source, GEvent event) { //_CODE_:clearNodes:323710:
  nodes = new ArrayList<Node>();
  edges = new ArrayList<Edge>();
  blocks = new ArrayList<Block>();
  for(Edge e: edges){
    if(e.col == blocked){
      e.col = og;
      e.exists=true;
    }
  }
  runStart = false;
  run.setText("Run");
  startNode = null;
  endNode = null;
  nodeLabel = 0;
} //_CODE_:clearNodes:323710:

public void resetBlock_click(GButton source, GEvent event) { //_CODE_:resetBlocks:291964:
  blocks = new ArrayList<Block>();
  for(Edge e: edges){
    if(e.col == blocked){
      e.col = og;
      e.exists=true;
    }
  }
  if(runStart){
    setValues();
    findPath();
  }
} //_CODE_:resetBlocks:291964:

public void instructions_click1(GImageButton source, GEvent event) { //_CODE_:instructions:377120:
  if(!instruction){
    window2 = GWindow.getWindow(this, "Instructions", 0, 0, 310, 330, JAVA2D);
    window2.noLoop();
    window2.setActionOnClose(G4P.KEEP_OPEN);
    window2.addDrawHandler(this, "win_draw2");
    Title = new GLabel(window2, 19, 6, 267, 51);
    Title.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
    Title.setText("Welcome to PathFinder Pro! \nYou make a graph, I solve it (if it's possible of course)");
    Title.setOpaque(false);
    nodeText = new GLabel(window2, 13, 58, 278, 57);
    nodeText.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
    nodeText.setText("To add a point (node), set mode to \"Node\" and click to place a node. Indicate start/end nodes by checking the box before placing them");
    nodeText.setOpaque(false);
    edgeLabel = new GLabel(window2, 11, 120, 281, 49);
    edgeLabel.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
    edgeLabel.setText("To connect nodes, set mode to \"Edge\" and click on the two nodes you want to connect");
    edgeLabel.setOpaque(false);
    blockLabel = new GLabel(window2, 8, 174, 288, 63);
    blockLabel.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
    blockLabel.setText("To block a path (edge), set mode to \"Road block\" and click on the edge you wish to block (clicking on intersections will remove all edges involved)");
    blockLabel.setOpaque(false);
    note = new GLabel(window2, 5, 245, 294, 68);
    note.setTextAlign(GAlign.CENTER, GAlign.MIDDLE);
    note.setText("*Notes: The default mode \"(Select)\"  allows you to drag nodes around. You can also edit edges, nodes and blocks while the program runs. Oh and also, you can only have one start and end node.");
    note.setOpaque(false);
    window2.loop();
    instruction = true;
  }
  else{
    instruction = false;
  }
} //_CODE_:instructions:377120:

public void generateGraph_click1(GButton source, GEvent event) { //_CODE_:generateGraph:638322:
  nodes = new ArrayList<Node>();
  edges = new ArrayList<Edge>();
  runStart = false;
  run.setText("Run");
  generateGraph();
} //_CODE_:generateGraph:638322:

synchronized public void win_draw2(PApplet appc, GWinData data) { //_CODE_:window2:229130:
  appc.background(230);
} //_CODE_:window2:229130:



// Create all the GUI controls. 
// autogenerated do not edit
public void createGUI(){
  G4P.messagesEnabled(false);
  G4P.setGlobalColorScheme(GCScheme.BLUE_SCHEME);
  G4P.setMouseOverEnabled(false);
  surface.setTitle("Sketch Window");
  window1 = GWindow.getWindow(this, "PathFinderPro GUI", 0, 0, 300, 300, JAVA2D);
  window1.noLoop();
  window1.setActionOnClose(G4P.KEEP_OPEN);
  window1.addDrawHandler(this, "win_draw1");
  options = new GDropList(window1, 24, 18, 110, 112, 3, 10);
  options.setItems(loadStrings("list_216535"), 0);
  options.addEventHandler(this, "options_click1");
  startCheckbox = new GCheckbox(window1, 152, 20, 79, 16);
  startCheckbox.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  startCheckbox.setText("Start Node");
  startCheckbox.setOpaque(false);
  startCheckbox.addEventHandler(this, "startCheckbox_clicked");
  endCheckBox = new GCheckbox(window1, 151, 46, 81, 20);
  endCheckBox.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  endCheckBox.setText("End Node");
  endCheckBox.setOpaque(false);
  endCheckBox.addEventHandler(this, "endCheckBox_clicked");
  clearEdgesButton = new GButton(window1, 107, 147, 67, 36);
  clearEdgesButton.setText("Clear Edges");
  clearEdgesButton.addEventHandler(this, "clearEdges_click");
  togGroup1 = new GToggleGroup();
  run = new GButton(window1, 96, 238, 80, 30);
  run.setText("Run");
  run.addEventHandler(this, "runButton_click");
  showDist = new GCheckbox(window1, 18, 203, 120, 20);
  showDist.setIconAlign(GAlign.LEFT, GAlign.MIDDLE);
  showDist.setText("Display distances");
  showDist.setOpaque(false);
  showDist.addEventHandler(this, "showDist_clicked");
  clearNodes = new GButton(window1, 196, 148, 68, 36);
  clearNodes.setText("Clear Nodes");
  clearNodes.addEventHandler(this, "clearNodes_click");
  resetBlocks = new GButton(window1, 16, 147, 74, 34);
  resetBlocks.setText("Clear road blocks");
  resetBlocks.addEventHandler(this, "resetBlock_click");
  instructions = new GImageButton(window1, 252, 8, 25, 24, new String[] { "question.png", "question.png", "question.png" } );
  instructions.addEventHandler(this, "instructions_click1");
  generateGraph = new GButton(window1, 87, 95, 105, 32);
  generateGraph.setText("Generate Random Graph");
  generateGraph.addEventHandler(this, "generateGraph_click1");
  window1.loop();
}

// Variable declarations 
// autogenerated do not edit
GWindow window1;
GDropList options; 
GCheckbox startCheckbox; 
GCheckbox endCheckBox; 
GButton clearEdgesButton; 
GToggleGroup togGroup1; 
GButton run; 
GCheckbox showDist; 
GButton clearNodes; 
GButton resetBlocks; 
GImageButton instructions; 
GButton generateGraph; 
GWindow window2;
GLabel Title; 
GLabel nodeText; 
GLabel edgeLabel; 
GLabel blockLabel; 
GLabel note; 
Node tmpNode1 = null, tmpNode2 = null;

boolean update;
String alpha = "abcdefghijklmnopqrstuvwxyzABCDEFGHJIKLMNOPQRSTUVWXYZ";
int nodeLabel = 0;

public void mousePressed(){
  if(mode.equals("node")){
    Node tmpNode = null;
    if(startChecked && startNode == null){ //only assign a node as the starting point if no other node has been assigned as such
       tmpNode = new Node(mouseX, mouseY,"Start");
       startNode = tmpNode;
    }
    else if(endChecked && endNode == null &&!startChecked){
       tmpNode = new Node(mouseX, mouseY, "End");
       endNode = tmpNode;
    }
    else {
      tmpNode = new Node(mouseX, mouseY, str(alpha.charAt(nodeLabel)));
      nodeLabel++;
      if(nodeLabel>51) nodeLabel = 0;
    }
    nodes.add(tmpNode);
  }
  
  if(mode.equals("edge")){
    for(Node n: nodes){
      if(n.isClicked() && tmpNode1 == null){
        tmpNode1 = n;
      }
      else if(n.isClicked() && tmpNode1!=null && n.x != tmpNode1.x && n.y != tmpNode1.y){
        tmpNode2 = n;
        
        edges.add(new Edge (tmpNode1, tmpNode2));
        tmpNode1 = null;
        tmpNode2 = null;
        
      }
    
    }
    for(Node n: nodes){
      if(!n.isClicked() && n.col!=chosenPath) n.col=og;
    }
    
  }
  if(mode.equals("block")){
    for(Edge e: edges){
      if(e.isClicked()){
        e.col = blocked;
        e.exists=false;
        blocks.add(new Block(e));
      }
    }
  }
  if(runStart){ //usually needs to recalculating after modifying edges, nodes or blocks
     setValues(); 
     findPath();
  }
}


public void mouseDragged(){
  Node selectedNode = null;
  for(Node n:nodes){
    if(n.isClicked()){
      selectedNode = n;
      update = true;
      break;
    }
    
  }
  if(selectedNode!=null){
    selectedNode.x = mouseX;
    selectedNode.y = mouseY;
  }
  
  for(Edge e: edges){
    e.updateDist();
  }
  
}

public void mouseReleased(){
  if(update && runStart){
      setValues();
      findPath();
      update = false;
  }
}




//Arrays
ArrayList<Node> nodes = new ArrayList<Node>();
ArrayList<Edge> edges = new ArrayList<Edge>();
ArrayList<Block> blocks = new ArrayList<Block>();

//Default Colors
int og = color(120, 172, 194);
int clicked = color (101, 143, 156);
int chosenPath = color(77, 201, 91);
int blocked = color(199, 123, 56);

//Images
PImage cone, name;

PFont display, f; //f is the general font for nodes

String mode = ""; //"Node", "Edge", "Block"

boolean startChecked = false, endChecked = false, showDistance = false;
boolean runStart = false;
boolean instruction = false;

public void setup(){
  createGUI();
  /* size commented out by preprocessor */;  
  noStroke();
  display = createFont("Cambria", 16);
  f = createFont("Cambria", 15);
  cone = loadImage("cone.png");
  name = loadImage("name.png");
  cone.resize(30,30);
  
}

public void draw(){
  background(224, 205, 188);
  imageMode(CENTER);
  image(name, 350, 50);
  try{
    for(Edge e: edges){
      e.drawEdge();
    }
    for(Block b: blocks){
      b.showBlock();
    }
    for(Node n: nodes){
      n.showNode();
    }
    
    fill(0);
    textFont(display);
    textAlign(RIGHT);
    if(endNode == null || startNode == null){
      text("*Incomplete graph, make sure you have a start and end node*", 650,100);
    }
    else if(!runStart) text("Shortest Distance: N/A", 650,100);
    else if(!endNode.vis && runStart){
      text("No path found", 650,100);
    }
    else text("Shortest Distance (to the nearest unit): "+str(round(endNode.SD)), 650,100);
  }
  catch(Exception e){ //Sometimes the generateGraph is still adding nodes/edges when the draw function runs which creates an error
 
  }
}

public void generateGraph(){
  int numNodes = round(random(3,10));
  int numEdges = round(random(3,20));
  nodeLabel = 0;

  startNode = new Node(round(random(110,600)), round(random(130,600)), "Start");
  endNode = new Node(round(random(110,600)), round(random(130,600)), "End");
  nodes.add(startNode); nodes.add(endNode);
  
  for(int i = 0; i < numNodes; i++){
    nodes.add(new Node(round(random(110,600)), round(random(130,600)), str(alpha.charAt(nodeLabel))));
    nodeLabel++;
  }
  for(int j = 0; j < numEdges; j++){
    int ind1 = PApplet.parseInt(random(0,numNodes)), ind2 =  PApplet.parseInt(random(0,numNodes)); //randomly gets two indices
    Node node1 = nodes.get(ind1);
    Node node2 = nodes.get(ind2);
    
    if(!(node1 == startNode && node2 == endNode) && !(node2 == startNode && node1 == endNode)){ //prevents a direct path from start to end (to make things more interesting)
      Edge newEdge = new Edge(node1,node2);
      if(!edges.contains(newEdge)){ //prevents duplicates
        edges.add(new Edge(node1,node2));
      }
    }
  }
}


  public void settings() { size(700, 700); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "a_Block" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
